#!/usr/bin/env python

from __future__ import print_function
__author__ = 'adam'

import argparse
import json
import os
import shutil

DEFAULT_CONFIGURATION_FILE = 'copycat.json'

class CopycatError(Exception):
    """ Raised when an error occurs in the copycat program. """
    pass

def load_config(config_file, to_dir, backup_dir):
    """ Load configuration JSON file. """
    cwd = os.getcwd()

    if config_file:
        config_file = os.path.expanduser(config_file)
    else:
        config_file = os.path.join(cwd, DEFAULT_CONFIGURATION_FILE)

    with open(config_file) as fp:
        config = json.load(fp)

    if not to_dir and 'location' in config:
        to_dir = os.path.join(cwd, config['location'])
    elif not to_dir:
        print('No directory specified for files.')
        return

    if not backup_dir and 'backup' in config:
        backup_dir = os.path.join(cwd, config['backup'])
    elif not backup_dir:
        print('No directory specified for backups.')
        return

    groups = config['groups']

    for group in groups:
        # Expand home directories if required.
        group['root'] = os.path.expanduser(group['root'])

        # Make paths to files absolute.
        if 'files' in group:
            group['files'] = [os.path.join(group['root'], fp)
                              for fp in group['files']]
        else:
            group['files'] = []
        if not 'repos' in group:
            group['repos'] = []
        if not 'exclude' in group:
            group['exclude'] = []
    return groups, to_dir, backup_dir

def groups_to_configure(only_groups, not_groups, all_groups):
    """ Determine which file groups to operate on. """

    only_groups = set(only_groups.split(' ')) if only_groups else set()
    not_groups = set(not_groups.split(' ')) if not_groups else set()

    if len(only_groups) > 0:
        return filter(lambda group: group['name'] in only_groups, all_groups)
    else:
        return filter(lambda group: group['name'] not in not_groups, all_groups)

def clean(groups, location, force):
    """ Remove the configuration files from the repo. """

    # If we are removing all types, just get rid of the whole directory.
    if force and os.path.isdir(location):
        shutil.rmtree(location)

    # Remove individual file type directories.
    for group in groups:
        try:
            shutil.rmtree(os.path.join(location, group['name']))
        except OSError:
            pass

    # If the file directory is now empty, get rid of that too.
    if os.path.isdir(location) and len(os.listdir(location)) == 0:
        shutil.rmtree(location)

def copy(groups, from_dir):
    """ Copy files from the local machine to the repo. """

    # TODO add try except here
    os.makedirs(from_dir)
    for group in groups:
        group_dir = os.path.join(from_dir, group['name'])
        os.makedirs(group_dir)

        for fp in group['files']:
            if os.path.exists(fp):
                if os.path.isfile(fp):
                    shutil.copy(fp, group_dir)
                elif os.path.isdir(fp):
                    ignore = shutil.ignore_patterns(*group['exclude'])
                    shutil.copytree(
                            fp,
                            os.path.join(group_dir, fp.split(os.path.sep)[-1]),
                            ignore=ignore)

            else:
                print('{} does not exist'.format(fp))

def paste(groups, to_dir):
    """ Paste configuration files into the correct places on the system. """

    # Import git if required.
    for group in groups:
        if len(group['repos']) > 0:
            import git
            break

    for group in groups:
        group_dir = os.path.join(to_dir, group['name'])
        for fp in group['files']:
            file_name = fp.split(os.path.sep)[-1]
            group_path = os.path.join(group_dir, file_name)
            if os.path.isdir(group_path):
                if os.path.isdir(fp):
                    shutil.rmtree(fp)
                shutil.copytree(group_path, fp)
            elif os.path.isfile(group_path):
                shutil.copy(group_path, fp)
        # for dp in group['dirs']:
        #     dir_name = dp.split(os.path.sep)[-1]
        #     if os.path.isdir(dp):
        #         shutil.rmtree(dp)
        #     shutil.copytree(os.path.join(group_dir, dir_name), dp)
        for repo in group['repos']:
            repo_dir = os.path.join(group['root'], repo['dir'])
            if os.path.isdir(repo_dir):
                shutil.rmtree(repo_dir)
            print('Cloning {}...'.format(repo['url']))
            git_repo = git.Repo().clone_from(repo['url'], repo_dir)
            git_repo.submodule_update()

def backup(groups, backup_dir):
    """ Back up files in a separate directory. """
    if os.path.isdir(backup_dir):
        shutil.rmtree(backup_dir)
    copy(groups, backup_dir)

def bundle(location):
    """ Bundle the files into a tar.gz. """
    import tarfile
    tarname = location + '.tar.gz'
    if os.path.isfile(tarname):
        print('{} already exists!'.format(tarname))
    with tarfile.open(tarname, 'w:gz') as tar:
        try:
            tar.add(os.path.relpath(location))
        except OSError:
            raise CopycatError('You need to run "copycat copy" first.')
    return tarname

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('command', help="Command to perform. Can be one of"
                        " 'clean', 'copy', 'paste', or 'bundle'.")
    parser.add_argument('-n', '--not', help='File groups to exclude.',
                        dest='not_groups', metavar='GROUPS')
    parser.add_argument('-o', '--only', help='Only include these file groups.',
                        dest='only_groups', metavar='GROUPS')
    parser.add_argument('-f', '--force', help='Force clean command to remove '
                        'all files.', action='store_true')
    parser.add_argument('-c', '--config', help='Specify configuration file to '
                        'use. Default is {}.'
                        .format(DEFAULT_CONFIGURATION_FILE))
    parser.add_argument('-l', '--location', help='Directory to copy files to '
                        'and from. If specified, overrides location field in '
                        'configuration file.')
    parser.add_argument('-b', '--backup', help='Directory to backup files '
                        'to. If specified, overrides backup field in '
                        'configuration file.')
    args = parser.parse_args()

    all_groups, location, backup_dir = load_config(args.config, args.location,
                                                   args.backup)
    groups = groups_to_configure(args.only_groups, args.not_groups, all_groups)
    rel_location = os.path.relpath(location)

    command = args.command
    if command == 'clean':
        clean(groups, location, args.force)
        print('Files removed from \'{}\'.'.format(rel_location))
    elif command == 'copy':
        clean(groups, location, args.force)
        copy(groups, location)
        print('Files copied into \'{}\'.'.format(rel_location))
    elif command == 'paste':
        prompt = raw_input('Are you sure you want to overwrite your'
                           + ' local files? [y/N] ')
        if prompt.upper() == 'Y' or prompt.upper() == 'YES':
            backup(groups, backup_dir)
            paste(groups, location)
            print('Files pasted from \'{}\'. Local files backed up to \'{}\''
                  .format(rel_location, os.path.relpath(backup_dir)))
        else:
            print('Aborted.')
    elif command == 'bundle':
        tarname = bundle(location)
        print('Bundled into \'{}\'.'.format(os.path.relpath(tarname)))
    else:
        print('Unrecognized command.')

if __name__ == '__main__':
    try:
        main()
    except CopycatError as e:
        print(e.message)

